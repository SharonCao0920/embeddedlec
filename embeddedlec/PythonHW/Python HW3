#Author: Sharon Cao
#Description:
#1. Write a function to implement intersects, which takes a one-argument function f and
#argument “x”, returns a function g. It returns True if f(x)=g(x), otherwise False.
 """Returns a function that returns if f intersects g at x.
 >>> at_three = intscts (square, 3)
 >>> at_three(triple) # triple(3) == square(3)
 True
 >>> at_three(increment)
 False
 >>> at_one = intscts (identity, 1)
 >>> at_one(square)
 True
 >>> at_one(triple)
 24
 >>> a2(5)
 35
 >>> a3 = add (a1, a2) # (x + x^2) + (x + x^2 + x)
 >>> a3(4)
 4
 """
def square(x):
    return x * x

def triple(x):
    return 3 * x

def identity(x):
    return x

def increment(x):
    return x + 1

 
def intscts(f, x):
     def ret(g):
         if g(x) == f(x):
            return True
         return False
     return ret

"""    
>>>at3 = intscts(square, 3)  
>>>print (at3 (increment))
False
""" 
#Author: Sharon Cao
#Description:
#2.Generate a function to implement the following calculations 
 """ 
 Return a function that takes in a single variable x, and returns g1(x) + g2(x). You 
can assume the result of g1(x) and g2(x) can be added together, and they both 
take in one argument. 
 >>> identity = lambda x: x # returns input 
 >>> square = lambda x: x**2 
 >>> a1 = add (identity, square) # x + x^2 
 >>> a1(4) 
 20 
 >>> a2 = add (a1, identity) # (x + x^2) + x 
 >>> a2(4) 
 24 
 >>> a2(5) 
 35 
 >>> a3 = add (a1, a2) # (x + x^2) + (x + x^2 + x) 
 >>> a3(4) 
 44
""" 
def add(g1, g2):
    def addfunc(x):
      return g1(x) + g2(x)
    return addfunc

identity = lambda x:x
square = lambda x:x**2
a1 = add (identity, square) 
print(a1(4)) 
a2 = add (a1, identity) 
print(a2(4)) 
print(a2(5))
a3 = add (a1, a2) 
print(a3(4)) 

"""
20
24
35
44
"""
 
#Author: Sharon Cao
#Description: 
#3. Complete the following function
 """
 >>> f()()(3)()
 3
 """
 YOUR CODE
 def f():
  def x():
    def y(n):
      print(n)
      def z():
        pass
      return z
    return y
  return x
  
 f()()(3)()
 
"""
3
"""
 
#Author: Sharon Cao
#Description: 
#4. Define a function “smth” that takes a function g and a value to use for dx and returns a
#function that computes the smoothed version of g. Do NOT use any “def” statements
#inside of “smth”, but use lambda expressions instead.
 """Returns the smoothed version of g, f where
 f(x) = (g(x - dx) + g(x) + g(x + dx)) / 3
 >>> square = lambda x: x ** 2
 >>> round(smth(square, 1)(0), 3)
 0.667
 """
def smth(g, dx):
  return lambda x: ((g(x-dx) + g(x) + g(x + dx))/3)
 
square = lambda x: x ** 2
print(round(smth(square, 1)(0), 3))

"""
0.667
"""
  
 
#Author: Sharon Cao
#Description: 
#5. Define a high-order function (one parameter n in second order function) to count number
#from 1 to n to meet f (function parameter in first order function) conditional requirement.
 """
 >>> cnt_cd (lambda n, i: n % i == 0)(2) # 2 factors from 1 to 2
 2
 >>> cnt_cd (lambda n, i: n % i == 0)(4) # 3 factors 1, 2, 4 from 1 to 4
 >>> cnt_cd (lambda n, i: n % i == 0)(12) # 6 factors 1, 2, 3, 4, 6, 12 from 1 to 12
 6
 >>> cnt_cd (is_prime)(2) # 1 prime number from 1 to 2
 1
 >>> cnt_cd (is_prime)(3) # 2 prime numbers 2, 3 from 1 to 3
 2
 >>> cnt_cd (is_prime)(4) # 2 prime numbers 2, 3 from 1 to 4
 2
 >>> cnt_cd (is_prime)(5) # 3 prime numbers 2, 3, 5 from 1 to 5
 3
 >>> cnt_cd (is_prime)(20) # 8 prime numbers 2, 3, 5, 7, 11, 13, 17, 19 from 1 to 20
 8 
"""
def cnt_cd(f):
  def x(m):
    if (m == 1):
      return 0
    elif(f(m) or f(m)):
      return 1 + cnt_cd(f)(m-1)
    else:
      return 0 + cnt_cd(f)(m-1)
  return x
 
def is_prime(m):
  tmp = m -1
  while (tmp > 1):
    if (m % tmp == 0):
      return False
    tmp -= 1
  return True

print(cnt_cd (is_prime)(2))
print(cnt_cd (is_prime)(3))
print(cnt_cd (is_prime)(4))
print(cnt_cd (is_prime)(5))
print(cnt_cd (is_prime)(20))

"""
1
2
2
3
8
"""
#Author: Sharon Cao
#Description:
#6. Credit card number is based on an algorithm, such as there are 6 digits in the first row
#on the following table, and from the rightmost digit, moving left, double the value of
#every second digit in the blue box; if product of this doubling operation is greater than
#9 (e.g. 7 * 2 = 14), then sum the digits of the products (e.g. 14: 1 + 4 = 5, 10: 1 + 0 =
#1,), and take the sum of all the digits
 """Return the digit sum of n computed by the algorithm.
 >>> card_sum (2)
 2
 >>> card_sum (12) # 2*1 + 2 = 4
 4
 >>> card_sum (42) # 4*2 + 2 = 10
 10
 >>> card_sum (138743) # 2*1+3+(2*8=16=>1+6=7) +7+2*4+3
 30
 >>> card_sum (5105105105105100)
 20
 >>> card_sum (4012888888881881)
 90
 >>> card_sum (79927398713)
 70
 """
 
 def get_Digit(x):
  return x%10

def sumdigits(m):
  total = 0
  n = 1
  while (m > 0):
    if (n % 2 != 0):
      total += get_Digit(m)
    else:
      if (get_Digit(m)*2 > 9):
        total += 1 + (get_Digit(m*2))
      else:
        total += get_Digit(m*2)
    m//= 10
    n += 1
  return total

print(sumdigits (2))
print(sumdigits (12))
print(sumdigits (42))
print(sumdigits (138743))
print(sumdigits (5105105105105100))
print(sumdigits (4012888888881881))
print(sumdigits (79927398713))

"""
2
4
10
30
20
90
70
"""
 
#Author: Sharon Cao
#Description: 
#7. Define a function by lambda expression to implement Caesar cipher function.
"""Returns a one-argument Caesar cipher function. “generator” will be
using an operation 'operation' (add or sub) to rotate a letter by an integer
n
 You may create “letter_to_n”and “n_to_letter” functions,
 which is to convert all letters a-z to 0-25 and all letters A-Z to 26-51.
 >>> letter_to_n ('a')
 0
 >>> letter_to_n ('c')
 2
 >>> n_to_letter (3)
 'd'
 >>> h = generator(2, add)
 >>> h('a')
 'c'
 >>> h = generator(3, sub)
 >>> brutus3('d')
 'a'
 """
 def generator(n, operation):
  return lambda m:(operation(m,n))

def letter_to_n(c):
  if (c >= 'A' and c <= 'Z'):
    return ord(c)-65
  else:
    return ord(c)-97

def n_to_letter(num):
  if (num >= 26 and num <= 51):
    return chr(num+39)
  else:
    return chr(num+97)

def add(x,y):
  x = letter_to_n(x)
  while (y > 0):
    x += 1
    y -= 1
  return n_to_letter(x)

def sub(x,y):
  x = letter_to_n(x)
  while (y > 0):
    x -= 1
    y -= 1
  return n_to_letter(x)


print(letter_to_n ('a'))
print(letter_to_n ('c'))
print(n_to_letter (3))
h = generator(2, add)
print(h('a'))
 
"""
0
2
d
c
""" 
 
#Author: Sharon Cao
#Description: 
#8. Define a function “cyc” that takes in three functions g1, g2, g3, as
#arguments. “cyc” will return another function that should take in an integer
#argument n and return another function. That final function should take in an
#argument x and cycle through applying g1, g2, and g3 to x, depending on what n was.
#Here's what the final function should do to x for a few values of n:
# n = 0, return x
# n = 1, apply g1 to x, or return g1(x)
# n = 2, apply g1 to x and then g2 to the result of that, or return g2(g1(x))
# n = 3, apply g1 to x, g2 to the result of applying g1, and then g3 to the
#result of applying g2, or g3(g2(g1(x)))
# n = 4, start the cycle again applying g1, then g2, then g3, then g1 again,
#or g1(g3(g2(g1(x))))
# And so forth.
#Hint: most of the work goes inside the most nested function.
 """ Returns a function that is itself a higher order function
 >>> def add_one(x):
 ... return x + 1
 >>> def times_two(x):
 ... return x * 2
 >>> def add_three(x):
 ... return x + 3
 >>> my_cyc = cyc(add_one, times_two, add_three)
 >>> h= my_cyc(0)
 >>> h(5)
 5
 >>> h = my_cyc(2)
 >>> h(1) # times_two (add_one (1))
 4
 >>> h = my_cyc(3)
 >>> h(2) # add_three (times_two (add_one (2)))
 9
 >>> h = my_cyc(4)
 >>> h(2) # add_one (add_three (times_two (add_one (2))))
 10
 >>> h = my_cyc(6)
 >>> h(1)
 19 #add_three(times_two (add_one (add_three (times_two (add_one (1))))))
 """
def add_one(x):
    return x + 1
def times_two(x):
    return x * 2
def add_three(x):
    return x + 3

def cyc(g1, g2, g3):
    def cycles(c):
        def result(n):
            a=0
            for i in range(0,c):
                if(a==0):
                    n=add_one(n)
                if(a==1):
                    n=times_two(n)
                if(a==2):
                    n=add_three(n)
                if(a%3==0 and i!=0):
                    n=add_one(n)
                if(a>2):
                    a=a%3
                a=a+1
            return n
        return result
    return cycles


my_cyc = cyc(add_one, times_two, add_three)
h= my_cyc(0)
print(h(5))
h = my_cyc(6)
print(h(1))
h = my_cyc(3)            
print(h(2)) 

"""
5
19
9
"""